const AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;

export function prepareSaveBundle(saveBundle, saveContext) {
    var em = saveContext.entityManager;
    var metadataStore = em.metadataStore;
    var helper = em.helper;

    var request = {};

    var entity = getRootEntity(saveBundle);
    var name = entity.entityType.name.substring(0, entity.entityType.name.indexOf(":"));

    request[name] = helper.unwrapInstance(entity);

    var autoGeneratedKey = null;
    if (entity.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
        autoGeneratedKey = {
            propertyName: entity.entityType.keyProperties[0].nameOnServer,
            autoGeneratedKeyType: entity.entityType.autoGeneratedKeyType.name
        };
    }

    // We also need to iterate through the navigation properties of the entity
    // and if navigation properties are not null - it means those properties
    // need to persist to the server as child objects in the root entity graph
    appendNavigationProperties(request[name], entity, saveBundle, em);

    var originalValuesOnServer = helper.unwrapOriginalValues(entity, metadataStore);
    request[name].entityAspect = {
        entityType: entity.entityType.name,
        entityState: entity.entityAspect.entityState.name
    };

    //saveBundle.saveOptions = { tag: saveBundle.saveOptions.tag };

    var saveBundleStringified = JSON.stringify(request);
    return saveBundleStringified;
}

export function getFlatEntityListFromGraph(saveContext, graph) {
    var entities = [];

    if(graph.entityAspect != null)
    {
        entities[entities.length] = graph;
    }
    else
    {
        visitEntityGraphNode(saveContext, graph, entities);
    }

    return entities;
}

function visitEntityGraphNode(saveContext, node, entities) {
    // Array of the properties of the current node that we should visit recursively
    var toVisitNext = [];
    var foundEntity = false;

    if(node.entityAspect != null)
    {
        foundEntity = true;

        entities[entities.length] = node;

        var entityType = saveContext.entityManager.metadataStore.getEntityType(node.entityAspect.entityType);
        toVisitNext = $.map(entityType.navigationProperties, function(navProp){
            return navProp.name;
        });
    }
    else
    {
        // Visit each key of the object (could be an array
        // or just wrapper properties)
        var type = get_type(node);
        if(type == "[object Object]" || type == "[object Array]")
        {
            toVisitNext = Object.keys(node);
        }

    }

    for(var k = 0; k < toVisitNext.length; k++)
    {
        var currentProp = toVisitNext[k];
        if(node[currentProp] != null)
        {
            var foundEntityInChildNode = visitEntityGraphNode(saveContext, node[currentProp], entities);
            if(foundEntityInChildNode)
            {
                delete node[currentProp];
            }
        }
    }

    return foundEntity;
}

// TODO: Use underscore or another library to do this reliably

/**
 * Gets the type of 'thing'
 * @param thing
 * @returns {string}
 */
function get_type(thing) {
    if(thing===null)return "[object Null]"; // special case
    return Object.prototype.toString.call(thing);
}

function getRootEntity(saveBundle) {
    var root = null;

    if(saveBundle.entities.length == 0)
    {
        return null;
    }

    // Default to the first entity
    var candidateRoot = saveBundle.entities[0];

    for(var i = 0; i < saveBundle.entities.length; i++)
    {
        var entity = saveBundle.entities[i];
        var parentEntities = getParentNavigationPropertyEntityTypes(entity);

        // We are done - we found an entity to be saved with no parent -
        // assume the first one we see of these is the 'root'
        if(parentEntities.length == 0)
        {
            return entity;
        }
        else
        {
            var bFoundParent = false;
            // Go through the parent entities - if we have find an entity in the
            // save bundle (changes that need to be persisted) that matches
            // one of the parent entities - then what we are looking at is
            // a child entity
            for(var p = 0; p < parentEntities.length; p++)
            {
                var matchingChangedEntities = findEntitiesByType(saveBundle.entities, parentEntities[p]);
                if(matchingChangedEntities.length > 0)
                {
                    bFoundParent = true;
                    break;
                }
            }

            if(!bFoundParent)
            {
                candidateRoot = entity;
            }
        }

    }

    return candidateRoot;
}

function getParentNavigationPropertyEntityTypes(entity) {
    var parentEntityTypes = [];

    for(var n = 0; n < entity.entityType.navigationProperties.length; n++) {

        var navProp = entity.entityType.navigationProperties[n];

        // The navigation points back at a parent entity
        if(navProp.relatedDataProperties != null && navProp.relatedDataProperties.length > 0)
        {
            parentEntityTypes[parentEntityTypes.length] = navProp.entityType.shortName;
        }
    }

    return parentEntityTypes;
}

function appendNavigationProperties(request, baseEntity, saveBundle, entityManager) {
    var em = entityManager;
    var metadataStore = em.metadataStore;
    var helper = em.helper;

    for(var n = 0; n < baseEntity.entityType.navigationProperties.length; n++) {

        var navProp = baseEntity.entityType.navigationProperties[n];

        // Any navigation property entities that need to be persisted to the server
        // should be in queued save bundle
        var navPropName = navProp.nameOnServer;

        // The navigation points back at a parent entity
        // we dont want to recursively cycle back and forth - so skip these
        // 'back link' nav properties
        if(navProp.relatedDataProperties != null && navProp.relatedDataProperties.length > 0)
        {
            continue;
        }

        // If this navigation property is a single object
        if(navProp.isScalar)
        {
            request[navPropName] = {};
        }
        else
        {
            // This nav property is a collection of entities
            request[navPropName] = [];
        }

        var navPropEntities = baseEntity[navPropName]();
        var deletedNavPropEntities = findDeletedEntitiesByType(saveBundle.entities, navProp.entityType.shortName);
        if(navPropEntities == null && navProp.isScalar)
        {
            navPropEntities = deletedNavPropEntities.length > 0 ? deletedNavPropEntities[0] : [];
        }
        if(!navProp.isScalar)
        {
            if(navPropEntities == null)
            {
                navPropEntities = [];
            }

            entities = navPropEntities.slice();
            if(deletedNavPropEntities.length > 0)
            {
                entities = entities.concat(deletedNavPropEntities);
            }

            navPropEntities = entities;
        }

        if(navProp.isScalar)
        {
            var navPropEntity = navPropEntities;
            // If no entity or entities exist(s) for this nav prop
            if(navPropEntity == null || navPropEntity.length == 0)
            {
                continue;
            }

            if(navPropEntity.entityAspect.entityState.isUnchanged())
            {
                continue;
            }
            var navPropEntityType = navPropEntity.entityAspect.entityGroup.entityType.shortName;

            var rawValue = helper.unwrapInstance(navPropEntity);
            rawValue.entityAspect = {
                entityType: navPropEntityType,
                entityState: navPropEntity.entityAspect.entityState.name
            };

            request[navPropName] = rawValue

            // Recursively go through this entity's navigation properties
            appendNavigationProperties(rawValue, navPropEntity, saveBundle, entityManager);
        }
        else
        {
            for(var i = 0; i < navPropEntities.length; i++)
            {
                var navPropEntity = navPropEntities[i];
                if(navPropEntity.entityAspect.entityState.isUnchanged())
                {
                    continue;
                }

                var navPropEntityType = navPropEntity.entityAspect.entityGroup.entityType.shortName;

                var rawValue = helper.unwrapInstance(navPropEntity);
                rawValue.entityAspect = {
                    entityType: navPropEntityType,
                    entityState: navPropEntity.entityAspect.entityState.name
                };

                request[navPropName].push(rawValue);

                // Recursively go through this entity's navigation properties
                appendNavigationProperties(rawValue, navPropEntity, saveBundle, entityManager);
            }
        }

    }
}

function findEntitiesByType(entities, typeName) {
    var matchingEntities = [];
    for(var i = 0; i < entities.length; i++)
    {
        var entity = entities[i];

        if(entity.entityType.shortName == typeName)
        {
            matchingEntities[matchingEntities.length] = entity;
        }
    }

    return matchingEntities;
}

function findDeletedEntitiesByType(entities, typeName) {
    let matchingEntities = [];
    for(let i = 0; i < entities.length; i++)
    {
        let entity = entities[i];

        if(entity.entityType.shortName == typeName && entity.entityAspect.entityState.isDeleted())
        {
            matchingEntities[matchingEntities.length] = entity;
        }
    }

    return matchingEntities;
}
/**
 * Custom Breeze DataService adapter to integrate with a generic RESTful service
 * that speaks JSON
 *
 * To use, include this library through requireJS or as a script tag - and call initializeAdapterInstances like:
 *
 * breeze.config.initializeAdapterInstances({dataService: "REST"});
 */
(function(factory) {
    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // CommonJS or Node: hard-coded dependency on "breeze"
        factory(require("breeze"));
    } else if (typeof define === "function" && define["amd"] && !breeze) {
        // AMD anonymous module with hard-coded dependency on "breeze"
        define(["breeze"], factory);
    } else {
        // <script> tag: use the global `breeze` object
        factory(breeze);
    }
}(function(breeze) {

    var core = breeze.core;

    var MetadataStore = breeze.MetadataStore;
    var JsonResultsAdapter = breeze.JsonResultsAdapter;
    var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;

    var ajaxImpl;

    var ctor = function () {
        this.name = "REST";
    };

    ctor.prototype.checkForRecomposition = function (interfaceInitializedArgs) {
        if (interfaceInitializedArgs.interfaceName === "ajax" && interfaceInitializedArgs.isDefault) {
            this.initialize();
        }
    };

    ctor.prototype.initialize = function () {
        ajaxImpl = breeze.config.getAdapterInstance("ajax");

        if (!ajaxImpl) {
            throw new Error("Unable to initialize ajax for REST adapter.");
        }

        // don't cache 'ajax' because we then we would need to ".bind" it, and don't want to because of brower support issues. 
        var ajax = ajaxImpl.ajax;
        if (!ajax) {
            throw new Error("Breeze was unable to find an 'ajax' adapter");
        }
    };

    ctor.prototype.fetchMetadata = function (metadataStore, dataService) {

        // TODO: In the future support WADL metadata?
        throw new Error("REST DataService adapter does not support metadata, set hasServerMetadata to 'false'");
    };


    ctor.prototype.executeQuery = function (mappingContext) {

        var deferred = Q.defer();

        var params = {
            url: mappingContext.url,
            dataType: 'json',
            success: function(data, textStatus, XHR) {
                try {
                    var rData;
                    if (data.Results) {
                        rData = { results: data.Results, inlineCount: data.InlineCount, XHR: XHR };
                    } else {
                        rData = { results: data, XHR: XHR };
                    }

                    deferred.resolve(rData);
                    XHR.onreadystatechange = null;
                    XHR.abort = null;
                } catch(e) {
                    var error = e instanceof Error ? e : createError(XHR);
                    // needed because it doesn't look like jquery calls .fail if an error occurs within the function
                    deferred.reject(error);
                    XHR.onreadystatechange = null;
                    XHR.abort = null;
                }

            },
            error: function(XHR, textStatus, errorThrown) {
                handleXHRError(deferred, XHR);
            }
        };
        if (mappingContext.dataService.useJsonp) {
            params.dataType = 'jsonp';
            params.crossDomain = true;
        }
        ajaxImpl.ajax(params);
        return deferred.promise;
    };

    ctor.prototype.saveChanges = function (saveContext, saveBundle) {

        var deferred = Q.defer();

        // Since the saveBundle can be a collection of changed entities - we
        // need to get the root entity if we assume that all changes are
        // part of an aggregate object graph
        var rootEntity = getRootEntity(saveBundle);
        var firstEntityName =  rootEntity.entityAspect.entityGroup.entityType.shortName;

        var bundle = prepareSaveBundle(saveBundle, saveContext);

        var verb;
        /** Look at the entity state to see which HTTP verb to use
            EntityState.Unchanged
            EntityState.Added
            EntityState.Modified
            EntityState.Deleted
            EntityState.Detached
         **/
        var entityState =  rootEntity.entityAspect.entityState.name;
        switch(entityState)
        {
            case breeze.EntityState.Added.name:
                verb = "POST";
                break;
            case breeze.EntityState.Modified.name:
                verb = "PUT";
                break;
            case breeze.EntityState.Deleted.name:
                verb = "DELETE";
                break;
            case breeze.EntityState.Detached.name:
            case breeze.EntityState.Unchanged.name:
            default:
                //logger.log("Skipping changes to entity: " + firstEntityName + " entity state: " + entityState);

                var saveResult = { entities: [], keyMappings: { forEach: function(){}}, XHR: null };
                deferred.resolve(saveResult);

                return deferred.promise;
                break;
        }

        var baseUrl = saveContext.dataService.serviceName;
        var url;

        var entityType = saveContext.entityManager.metadataStore.getEntityType(firstEntityName);
        if(entityType == null)
        {
            throw new Error("[Breeze DataService REST] entity type: " + firstEntityName + " not supported to save changes as root entity");
        }

        var resourceName = entityType.resourceName || entityType.defaultResourceName;

        url = baseUrl + resourceName;

        if(verb != "POST")
        {
            if(rootEntity.id == null || rootEntity.id() == null){
                throw new Error("[breeze.dataService.rest] - Entity type: " + firstEntityName + " must have an 'id' key property");
            }
            url = url + "/" + rootEntity.id();
        }

        var apiManagerToken = $.cookie("cvp_api_access_token");

        ajaxImpl.ajax({
            url: url,
            type: verb,
            dataType: 'json',
            contentType: "application/json",
            data: bundle,
            success: function(data, textStatus, XHR) {

                // Mark all the entities as unchanged since the save was successful
                var entities = saveBundle.entities;
                $.each(saveBundle.entities, function(i, entity){
                    entity.entityAspect.setUnchanged();
                });

                // Need to pass the following to Breeze in order for it process
                // the save correctly
                // entities - an array of all the entities that were saved/updated
                //            on the server in order for it to merge id values from the server
                //            on the client entities if the server generated ids.  There is
                //            no problematic behavior if you dont return any entities here if
                //            the server didnt generate an id.  However in cases where the server
                //            generates an id (entity is added) - you will need to return it here
                //            in order to update the client
                // keyMappings - an array of Key map objects that tell Breeze, for this entity type with this
                //               'old' id (named tempValue), the server updated the id to 'realValue'.  Each key map
                //               in this array should correspond to the entity in the same index in the 'entities' array
                //               This means that although the server may have responded with many entities, only the
                //               entities with server generated keys should an item in 'entities' and 'keyMappings' array
                // XHR - the raw XHR response object (from jQuery)

                var responseEntities = getFlatEntityListFromGraph(saveContext, data);

                var rootEntity = data;
                var keyMappings = [];
                var rawEntities = [];
                $.each(responseEntities, function(idx, entity){

                    // If there is no key mapping - then dont need to return the entity
                    // to breeze for any merging of server updated properties
                    if(entity.keyMapping == null)
                    {
                        return;
                    }

                    var keyMap = {
                        tempValue: entity.keyMapping.tempValue,
                        realValue: entity.keyMapping.realValue,
                        entityTypeName: entity.entityAspect.entityType
                    };

                    if(keyMap.tempValue == null)
                    {
                        // If the server side doesn't return a tempValue then assume
                        // we don't need to fix up a client key
                        return;
                    }

                    // If the entity type name does not contain the namespace - manually
                    // add the CVP namespace
                    if(keyMap.entityTypeName.indexOf(":") < 0)
                    {
                        var entityType = saveContext.entityManager.metadataStore.getEntityType(keyMap.entityTypeName);
                        keyMap.entityTypeName = entityType.name;
                    }
                    keyMappings[keyMappings.length] = keyMap;

                    makeRawEntity(entity);
                    rawEntities[rawEntities.length] = entity;
                });

                // Breeze expects that the responses from the server dont include
                // the entityAspect propert, so we make our server responses look 'raw'
                function makeRawEntity(entity)
                {
                    if(entity.entityAspect != null)
                    {
                        delete entity.entityAspect;
                    }
                }

                var saveResult = { entities: rawEntities, keyMappings: keyMappings, XHR: XHR };
                deferred.resolve(saveResult);
            },
            error: function (XHR, textStatus, errorThrown) {
                handleXHRError(deferred, XHR);
            }
        });

        return deferred.promise;
    };



    ctor.prototype.jsonResultsAdapter = new JsonResultsAdapter({

        name: "webApi_default",

        visitNode: function (node, mappingContext, nodeContext) {
            if (node == null) return {};
            var entityTypeName = MetadataStore.normalizeTypeName(node.$type);
            var entityType = entityTypeName && mappingContext.entityManager.metadataStore._getEntityType(entityTypeName, true);
            var propertyName = nodeContext.propertyName;
            var ignore = propertyName && propertyName.substr(0, 1) === "$";

            return {
                entityType: entityType,
                nodeId: node.$id,
                nodeRefId: node.$ref,
                ignore: ignore
            };
        }

    });

    breeze.config.registerAdapter("dataService", ctor);

}));
/**
 * Custom Breeze DataService adapter to integrate with a generic RESTful service
 * that speaks JSON
 *
 * To use, include this library through requireJS or as a script tag - and call initializeAdapterInstances like:
 *
 * breeze.config.initializeAdapterInstances({dataService: "REST"});
 */
(function(factory) {
    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // CommonJS or Node: hard-coded dependency on "breeze"
        factory(require("breeze"));
    } else if (typeof define === "function" && define["amd"] && !breeze) {
        // AMD anonymous module with hard-coded dependency on "breeze"
        define(["breeze"], factory);
    } else {
        // <script> tag: use the global `breeze` object
        factory(breeze);
    }
}(function(breeze) {

    var core = breeze.core;

    var MetadataStore = breeze.MetadataStore;
    var JsonResultsAdapter = breeze.JsonResultsAdapter;
    var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;

    var ajaxImpl;

    var ctor = function () {
        this.name = "REST";
    };

    ctor.prototype.checkForRecomposition = function (interfaceInitializedArgs) {
        if (interfaceInitializedArgs.interfaceName === "ajax" && interfaceInitializedArgs.isDefault) {
            this.initialize();
        }
    };

    ctor.prototype.initialize = function () {
        ajaxImpl = breeze.config.getAdapterInstance("ajax");

        if (!ajaxImpl) {
            throw new Error("Unable to initialize ajax for REST adapter.");
        }

        // don't cache 'ajax' because we then we would need to ".bind" it, and don't want to because of brower support issues. 
        var ajax = ajaxImpl.ajax;
        if (!ajax) {
            throw new Error("Breeze was unable to find an 'ajax' adapter");
        }
    };

    ctor.prototype.fetchMetadata = function (metadataStore, dataService) {

        // TODO: In the future support WADL metadata?
        throw new Error("REST DataService adapter does not support metadata, set hasServerMetadata to 'false'");
    };


    ctor.prototype.executeQuery = function (mappingContext) {

        var deferred = Q.defer();

        var params = {
            url: mappingContext.url,
            dataType: 'json',
            success: function(data, textStatus, XHR) {
                try {
                    var rData;
                    if (data.Results) {
                        rData = { results: data.Results, inlineCount: data.InlineCount, XHR: XHR };
                    } else {
                        rData = { results: data, XHR: XHR };
                    }

                    deferred.resolve(rData);
                    XHR.onreadystatechange = null;
                    XHR.abort = null;
                } catch(e) {
                    var error = e instanceof Error ? e : createError(XHR);
                    // needed because it doesn't look like jquery calls .fail if an error occurs within the function
                    deferred.reject(error);
                    XHR.onreadystatechange = null;
                    XHR.abort = null;
                }

            },
            error: function(XHR, textStatus, errorThrown) {
                handleXHRError(deferred, XHR);
            }
        };
        if (mappingContext.dataService.useJsonp) {
            params.dataType = 'jsonp';
            params.crossDomain = true;
        }
        ajaxImpl.ajax(params);
        return deferred.promise;
    };

    ctor.prototype.saveChanges = function (saveContext, saveBundle) {

        var deferred = Q.defer();

        // Since the saveBundle can be a collection of changed entities - we
        // need to get the root entity if we assume that all changes are
        // part of an aggregate object graph
        var rootEntity = getRootEntity(saveBundle);
        var firstEntityName =  rootEntity.entityAspect.entityGroup.entityType.shortName;

        var bundle = prepareSaveBundle(saveBundle, saveContext);

        var verb;
        /** Look at the entity state to see which HTTP verb to use
            EntityState.Unchanged
            EntityState.Added
            EntityState.Modified
            EntityState.Deleted
            EntityState.Detached
         **/
        var entityState =  rootEntity.entityAspect.entityState.name;
        switch(entityState)
        {
            case breeze.EntityState.Added.name:
                verb = "POST";
                break;
            case breeze.EntityState.Modified.name:
                verb = "PUT";
                break;
            case breeze.EntityState.Deleted.name:
                verb = "DELETE";
                break;
            case breeze.EntityState.Detached.name:
            case breeze.EntityState.Unchanged.name:
            default:
                //logger.log("Skipping changes to entity: " + firstEntityName + " entity state: " + entityState);

                var saveResult = { entities: [], keyMappings: { forEach: function(){}}, XHR: null };
                deferred.resolve(saveResult);

                return deferred.promise;
                break;
        }

        var baseUrl = saveContext.dataService.serviceName;
        var url;

        var entityType = saveContext.entityManager.metadataStore.getEntityType(firstEntityName);
        if(entityType == null)
        {
            throw new Error("[Breeze DataService REST] entity type: " + firstEntityName + " not supported to save changes as root entity");
        }

        url = baseUrl + entityType.defaultResourceName

        if(verb != "POST")
        {
            if(rootEntity.id == null || rootEntity.id() == null){
                throw new Error("[breeze.dataService.rest] - Entity type: " + firstEntityName + " must have an 'id' key property");
            }
            url = baseUrl + entityType.defaultResourceName + "/" + rootEntity.id();
        }

        var apiManagerToken = $.cookie("cvp_api_access_token");

        ajaxImpl.ajax({
            url: url,
            type: verb,
            dataType: 'json',
            contentType: "application/json",
            data: bundle,
            success: function(data, textStatus, XHR) {

                // Mark all the entities as unchanged since the save was successful
                var entities = saveBundle.entities;
                $.each(saveBundle.entities, function(i, entity){
                    entity.entityAspect.setUnchanged();
                });

                // Need to pass the following to Breeze in order for it process
                // the save correctly
                // entities - an array of all the entities that were saved/updated
                //            on the server in order for it to merge id values from the server
                //            on the client entities if the server generated ids.  There is
                //            no problematic behavior if you dont return any entities here if
                //            the server didnt generate an id.  However in cases where the server
                //            generates an id (entity is added) - you will need to return it here
                //            in order to update the client
                // keyMappings - an array of Key map objects that tell Breeze, for this entity type with this
                //               'old' id (named tempValue), the server updated the id to 'realValue'.  Each key map
                //               in this array should correspond to the entity in the same index in the 'entities' array
                //               This means that although the server may have responded with many entities, only the
                //               entities with server generated keys should an item in 'entities' and 'keyMappings' array
                // XHR - the raw XHR response object (from jQuery)

                var responseEntities = getFlatEntityListFromGraph(saveContext, data);

                var rootEntity = data;
                var keyMappings = [];
                var rawEntities = [];
                $.each(responseEntities, function(idx, entity){

                    // If there is no key mapping - then dont need to return the entity
                    // to breeze for any merging of server updated properties
                    if(entity.keyMapping == null)
                    {
                        return;
                    }

                    var keyMap = {
                        tempValue: entity.keyMapping.tempValue,
                        realValue: entity.keyMapping.realValue,
                        entityTypeName: entity.entityAspect.entityType
                    };

                    if(keyMap.tempValue == null)
                    {
                        // If the server side doesn't return a tempValue then assume
                        // we don't need to fix up a client key
                        return;
                    }

                    // If the entity type name does not contain the namespace - manually
                    // add the CVP namespace
                    if(keyMap.entityTypeName.indexOf(":") < 0)
                    {
                        var entityType = saveContext.entityManager.metadataStore.getEntityType(keyMap.entityTypeName);
                        keyMap.entityTypeName = entityType.name;
                    }
                    keyMappings[keyMappings.length] = keyMap;

                    makeRawEntity(entity);
                    rawEntities[rawEntities.length] = entity;
                });

                // Breeze expects that the responses from the server dont include
                // the entityAspect propert, so we make our server responses look 'raw'
                function makeRawEntity(entity)
                {
                    if(entity.entityAspect != null)
                    {
                        delete entity.entityAspect;
                    }
                }

                var saveResult = { entities: rawEntities, keyMappings: keyMappings, XHR: XHR };
                deferred.resolve(saveResult);
            },
            error: function (XHR, textStatus, errorThrown) {
                handleXHRError(deferred, XHR);
            }
        });

        return deferred.promise;
    };

    function prepareSaveBundle(saveBundle, saveContext) {
        var em = saveContext.entityManager;
        var metadataStore = em.metadataStore;
        var helper = em.helper;

        var request = {};

        var entity = getRootEntity(saveBundle);
        var name = entity.entityType.name.substring(0, entity.entityType.name.indexOf(":"));

        request[name] = helper.unwrapInstance(entity);

        var autoGeneratedKey = null;
        if (entity.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            autoGeneratedKey = {
                propertyName: entity.entityType.keyProperties[0].nameOnServer,
                autoGeneratedKeyType: entity.entityType.autoGeneratedKeyType.name
            };
        }

        // We also need to iterate through the navigation properties of the entity
        // and if navigation properties are not null - it means those properties
        // need to persist to the server as child objects in the root entity graph
        appendNavigationProperties(request[name], entity, saveBundle, em);

        var originalValuesOnServer = helper.unwrapOriginalValues(entity, metadataStore);
        request[name].entityAspect = {
            entityType: entity.entityType.name,
            entityState: entity.entityAspect.entityState.name
        };

        //saveBundle.saveOptions = { tag: saveBundle.saveOptions.tag };

        var saveBundleStringified = JSON.stringify(request);
        return saveBundleStringified;
    }

    function getFlatEntityListFromGraph(saveContext, graph)
    {
        var entities = [];

        if(graph.entityAspect != null)
        {
            entities[entities.length] = graph;
        }
        else
        {
            visitEntityGraphNode(saveContext, graph, entities);
        }

        return entities;
    }

    function visitEntityGraphNode(saveContext, node, entities)
    {
        // Array of the properties of the current node that we should visit recursively
        var toVisitNext = [];
        var foundEntity = false;

        if(node.entityAspect != null)
        {
            foundEntity = true;

            entities[entities.length] = node;

            var entityType = saveContext.entityManager.metadataStore.getEntityType(node.entityAspect.entityType);
            toVisitNext = $.map(entityType.navigationProperties, function(navProp){
                return navProp.name;
            });
        }
        else
        {
            // Visit each key of the object (could be an array
            // or just wrapper properties)
            var type = get_type(node);
            if(type == "[object Object]" || type == "[object Array]")
            {
                toVisitNext = Object.keys(node);
            }

        }

        for(var k = 0; k < toVisitNext.length; k++)
        {
            var currentProp = toVisitNext[k];
            if(node[currentProp] != null)
            {
                var foundEntityInChildNode = visitEntityGraphNode(saveContext, node[currentProp], entities);
                if(foundEntityInChildNode)
                {
                    delete node[currentProp];
                }
            }
        }

        return foundEntity;
    }

    // TODO: Use underscore or another library to do this reliably

    /**
     * Gets the type of 'thing'
     * @param thing
     * @returns {string}
     */
    function get_type(thing){
        if(thing===null)return "[object Null]"; // special case
        return Object.prototype.toString.call(thing);
    }

    function getRootEntity(saveBundle)
    {
        var root = null;

        if(saveBundle.entities.length == 0)
        {
            return null;
        }

        // Default to the first entity
        var candidateRoot = saveBundle.entities[0];

        for(var i = 0; i < saveBundle.entities.length; i++)
        {
            var entity = saveBundle.entities[i];
            var parentEntities = getParentNavigationPropertyEntityTypes(entity);

            // We are done - we found an entity to be saved with no parent -
            // assume the first one we see of these is the 'root'
            if(parentEntities.length == 0)
            {
                return entity;
            }
            else
            {
                var bFoundParent = false;
                // Go through the parent entities - if we have find an entity in the
                // save bundle (changes that need to be persisted) that matches
                // one of the parent entities - then what we are looking at is
                // a child entity
                for(var p = 0; p < parentEntities.length; p++)
                {
                    var matchingChangedEntities = findEntitiesByType(saveBundle.entities, parentEntities[p]);
                    if(matchingChangedEntities.length > 0)
                    {
                        bFoundParent = true;
                        break;
                    }
                }

                if(!bFoundParent)
                {
                    candidateRoot = entity;
                }
            }

        }

        return candidateRoot;
    }

    function getParentNavigationPropertyEntityTypes(entity)
    {
        var parentEntityTypes = [];

        for(var n = 0; n < entity.entityType.navigationProperties.length; n++) {

            var navProp = entity.entityType.navigationProperties[n];

            // The navigation points back at a parent entity
            if(navProp.relatedDataProperties != null && navProp.relatedDataProperties.length > 0)
            {
                parentEntityTypes[parentEntityTypes.length] = navProp.entityType.shortName;
            }
        }

        return parentEntityTypes;
    }

    function appendNavigationProperties(request, baseEntity, saveBundle, entityManager)
    {
        var em = entityManager;
        var metadataStore = em.metadataStore;
        var helper = em.helper;

        for(var n = 0; n < baseEntity.entityType.navigationProperties.length; n++) {

            var navProp = baseEntity.entityType.navigationProperties[n];

            // Any navigation property entities that need to be persisted to the server
            // should be in queued save bundle
            var navPropName = navProp.nameOnServer;

            // The navigation points back at a parent entity
            // we dont want to recursively cycle back and forth - so skip these
            // 'back link' nav properties
            if(navProp.relatedDataProperties != null && navProp.relatedDataProperties.length > 0)
            {
                continue;
            }

            // If this navigation property is a single object
            if(navProp.isScalar)
            {
                request[navPropName] = {};
            }
            else
            {
                // This nav property is a collection of entities
                request[navPropName] = [];
            }

            var navPropEntities = baseEntity[navPropName]();
            var deletedNavPropEntities = findDeletedEntitiesByType(saveBundle.entities, navProp.entityType.shortName);
            if(navPropEntities == null && navProp.isScalar)
            {
                navPropEntities = deletedNavPropEntities.length > 0 ? deletedNavPropEntities[0] : [];
            }
            if(!navProp.isScalar)
            {
                if(navPropEntities == null)
                {
                    navPropEntities = [];
                }

                entities = navPropEntities.slice();
                if(deletedNavPropEntities.length > 0)
                {
                    entities = entities.concat(deletedNavPropEntities);
                }

                navPropEntities = entities;
            }

            if(navProp.isScalar)
            {
                var navPropEntity = navPropEntities;
                // If no entity or entities exist(s) for this nav prop
                if(navPropEntity == null || navPropEntity.length == 0)
                {
                    continue;
                }

                if(navPropEntity.entityAspect.entityState.isUnchanged())
                {
                    continue;
                }
                var navPropEntityType = navPropEntity.entityAspect.entityGroup.entityType.shortName;

                var rawValue = helper.unwrapInstance(navPropEntity);
                rawValue.entityAspect = {
                    entityType: navPropEntityType,
                    entityState: navPropEntity.entityAspect.entityState.name
                };

                request[navPropName] = rawValue

                // Recursively go through this entity's navigation properties
                appendNavigationProperties(rawValue, navPropEntity, saveBundle, entityManager);
            }
            else
            {
                for(var i = 0; i < navPropEntities.length; i++)
                {
                    var navPropEntity = navPropEntities[i];
                    if(navPropEntity.entityAspect.entityState.isUnchanged())
                    {
                        continue;
                    }

                    var navPropEntityType = navPropEntity.entityAspect.entityGroup.entityType.shortName;

                    var rawValue = helper.unwrapInstance(navPropEntity);
                    rawValue.entityAspect = {
                        entityType: navPropEntityType,
                        entityState: navPropEntity.entityAspect.entityState.name
                    };

                    request[navPropName].push(rawValue);

                    // Recursively go through this entity's navigation properties
                    appendNavigationProperties(rawValue, navPropEntity, saveBundle, entityManager);
                }
            }

        }
    }

    function findEntitiesByType(entities, typeName)
    {
        var matchingEntities = [];
        for(var i = 0; i < entities.length; i++)
        {
            var entity = entities[i];

            if(entity.entityType.shortName == typeName)
            {
                matchingEntities[matchingEntities.length] = entity;
            }
        }

        return matchingEntities;
    }

    function findDeletedEntitiesByType(entities, typeName)
    {
        var matchingEntities = [];
        for(var i = 0; i < entities.length; i++)
        {
            var entity = entities[i];

            if(entity.entityType.shortName == typeName && entity.entityAspect.entityState.isDeleted())
            {
                matchingEntities[matchingEntities.length] = entity;
            }
        }

        return matchingEntities;
    }

    ctor.prototype.jsonResultsAdapter = new JsonResultsAdapter({

        name: "webApi_default",

        visitNode: function (node, mappingContext, nodeContext) {
            if (node == null) return {};
            var entityTypeName = MetadataStore.normalizeTypeName(node.$type);
            var entityType = entityTypeName && mappingContext.entityManager.metadataStore._getEntityType(entityTypeName, true);
            var propertyName = nodeContext.propertyName;
            var ignore = propertyName && propertyName.substr(0, 1) === "$";

            return {
                entityType: entityType,
                nodeId: node.$id,
                nodeRefId: node.$ref,
                ignore: ignore
            };
        }

    });


    function handleXHRError(deferred, XHR, messagePrefix) {
        var err = createError(XHR);
        if (messagePrefix) {
            err.message = messagePrefix + "; " + err.message;
        }
        deferred.reject(err);
        XHR.onreadystatechange = null;
        XHR.abort = null;
    }

    function createError(XHR) {

        var err = new Error();
        err.XHR = XHR;
        err.message = XHR.statusText;
        err.responseText = XHR.responseText;
        err.status = XHR.status;
        err.statusText = XHR.statusText;
        if (err.responseText) {
            try {
                var responseObj = JSON.parse(XHR.responseText);
                err.detail = responseObj;
                var source = responseObj.InnerException || responseObj;
                err.message = source.ExceptionMessage || source.Message || XHR.responseText;
            } catch (e) {

            }
        }
        return err;
    }

    breeze.config.registerAdapter("dataService", ctor);

}));